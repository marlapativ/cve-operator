/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"fmt"
	"slices"
	"strings"
	"time"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	githubv1 "github.com/csye7125-su24-team06/cve-operator/api/v1"
	"github.com/google/go-github/github"
	// Add this line to import the missing package
)

// GitHubReleasesMonitorReconciler reconciles a GitHubReleasesMonitor object
type GitHubReleasesMonitorReconciler struct {
	client.Client
	Scheme          *runtime.Scheme
	fetchedReleases *GitHubFetchedReleases
}

var (
	githubClient                   = github.NewClient(nil)
	jobOwnerKey                    = ".metadata.controller"
	apiGVStr                       = githubv1.GroupVersion.String()
	githubReleasesMonitorFinalizer = fmt.Sprintf("%s.%s/%s", githubv1.GroupVersion.Group, strings.ToLower("GitHubReleasesMonitor"), "finalizer")
	defaultRequeueAfter            = 5 * time.Minute
)

type GitHubFetchedReleases struct {
	Releases          []*github.RepositoryRelease
	LastRetrievedTime time.Time
}

// +kubebuilder:rbac:groups=github.csye7125-su24-team06,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=github.csye7125-su24-team06,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=github.csye7125-su24-team06,resources=githubreleasesmonitors/finalizers,verbs=update
// +kubebuilder:rbac:groups=batch,resources=jobs,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the GitHubReleasesMonitor object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.18.4/pkg/reconcile
func (r *GitHubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)

	// Fetch the GithubReleaseMonitor instance
	var githubReleaseMonitor githubv1.GitHubReleasesMonitor
	var githubReleases githubv1.GitHubReleaseList

	if err := r.Get(ctx, req.NamespacedName, &githubReleaseMonitor); err != nil {
		log.Error(err, "unable to fetch GithubReleaseMonitor")
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	// add finalizer to the GithubReleaseMonitor
	if githubReleaseMonitor.ObjectMeta.DeletionTimestamp.IsZero() {
		log.Info("Adding finalizer to GithubReleaseMonitor")
		if !controllerutil.ContainsFinalizer(&githubReleaseMonitor, githubReleasesMonitorFinalizer) {
			controllerutil.AddFinalizer(&githubReleaseMonitor, githubReleasesMonitorFinalizer)
			if err := r.Update(ctx, &githubReleaseMonitor); err != nil {
				log.Error(err, "unable to update GithubReleaseMonitor with finalizer")
				return ctrl.Result{}, err
			}

			return ctrl.Result{Requeue: true}, nil
		}
	} else {
		log.Info("GithubReleaseMonitor is being deleted")

		// Fetch child GithubRelease resources for the given GithubReleaseMonitor
		if err := r.List(ctx, &githubReleases, client.InNamespace(req.Namespace), client.MatchingFields{jobOwnerKey: req.Name}); err != nil {
			log.Error(err, "unable to list github releases")
			return ctrl.Result{}, err
		}

		// Handle deletion of the GithubReleaseMonitor
		if err := r.handleDeletion(ctx, &githubReleases, &githubReleaseMonitor); err != nil {
			log.Error(err, "unable to handle deletion of GithubReleaseMonitor")
			return ctrl.Result{}, err
		}
		return ctrl.Result{}, nil
	}

	// Set the MonitorFrom time if not set for first time
	status := githubReleaseMonitor.Status
	if status.MonitorFrom.IsZero() {

		log.Info("Setting MonitorFrom time for the first time")
		parsedTime, err := getTimeForMonitorFrom(githubReleaseMonitor.Spec.MonitorFrom)

		if err != nil {
			log.Error(err, "Error parsing monitorFrom time")
			return ctrl.Result{}, err
		}

		status.MonitorFrom = metav1.Time{Time: parsedTime}
	}

	// Fetch the releases for the given GithubReleaseMonitor
	if err := getReleases(r.fetchedReleases, status.MonitorFrom.Time, &githubReleaseMonitor, ctx); err != nil {
		log.Error(err, "Error fetching releases")
		return ctrl.Result{}, err
	}

	// Populate the status of the GithubReleaseMonitor
	populateStatus(&status, r.fetchedReleases)

	// Fetch child GithubRelease resources for the given GithubReleaseMonitor
	if err := r.List(ctx, &githubReleases, client.InNamespace(req.Namespace), client.MatchingFields{jobOwnerKey: req.Name}); err != nil {
		log.Error(err, "unable to list github releases")
		return ctrl.Result{}, err
	}

	// Build a map of GithubRelease resources for the given GithubReleaseMonitor
	githubReleaseIds := make(map[int64]bool)
	for _, githubRelease := range githubReleases.Items {
		githubReleaseIds[*githubRelease.Spec.ID] = true
	}

	// Build and Create a Job for each release that doesnot have a corresponding GithubRelease resource
	for _, release := range r.fetchedReleases.Releases {
		if _, ok := githubReleaseIds[release.GetID()]; !ok {
			githubReleaseName := fmt.Sprintf("githubrelease-%d", release.GetID())
			buildGithubRelease, err := r.buildGithubRelease(githubReleaseName, release, &githubReleaseMonitor)

			if err != nil {
				log.Error(err, "Error building GithubRelease")
				return ctrl.Result{}, err
			}

			log.Info("Creating GithubRelease", "GithubRelease", githubReleaseName)
			if err := r.Create(ctx, buildGithubRelease); err != nil {
				log.Error(err, "unable to create GithubRelease", "GithubRelease", buildGithubRelease)
				return ctrl.Result{}, err
			}
		}
	}

	// Update the status of the GithubReleaseMonitor
	githubReleaseMonitor.Status = status
	if err := r.Status().Update(ctx, &githubReleaseMonitor); err != nil {
		log.Error(err, "Error updating status")
		return ctrl.Result{}, err
	}

	return ctrl.Result{RequeueAfter: defaultRequeueAfter}, nil
}

func getTimeForMonitorFrom(monitorFrom string) (time.Time, error) {
	layout := "2006-01-02T15:04:05.000Z"
	if monitorFrom == "now" {
		return time.Now().UTC(), nil
	} else {
		parsedTime, err := time.Parse(layout, monitorFrom)
		if err != nil {
			return time.Time{}, err
		}

		return parsedTime, nil
	}
}

func populateStatus(status *githubv1.GitHubReleasesMonitorStatus, fetchedReleases *GitHubFetchedReleases) {
	if status.Releases == nil {
		status.Releases = []int64{}
	}

	for _, release := range fetchedReleases.Releases {
		if !slices.Contains(status.Releases, release.GetID()) {
			status.Releases = append(status.Releases, release.GetID())
		}
	}

	status.LastRetrievedTime = metav1.Time{Time: fetchedReleases.LastRetrievedTime}
}

func getReleases(fetchedReleases *GitHubFetchedReleases, monitorFrom time.Time, githubReleaseMonitor *githubv1.GitHubReleasesMonitor, ctx context.Context) error {
	log := log.FromContext(ctx)

	if time.Now().UTC().Before(githubReleaseMonitor.Status.LastRetrievedTime.Add(5 * time.Minute)) {
		log.Info("Skipping fetching releases as it was fetched recently",
			"LastRetrievedTime", githubReleaseMonitor.Status.LastRetrievedTime.UTC(),
			"CurrentTime", time.Now().UTC())

		return nil
	}

	listOptions := &github.ListOptions{
		Page:    1,
		PerPage: 30,
	}

	allReleasesFetched := false

	for !allReleasesFetched {
		releases, res, err := githubClient.Repositories.ListReleases(ctx, githubReleaseMonitor.Spec.Owner, githubReleaseMonitor.Spec.Repo, listOptions)

		if err != nil {
			log.Error(err, "Error fetching releases")
			return err
		}

		for _, release := range releases {
			if release.PublishedAt.After(monitorFrom) {
				fetchedReleases.Releases = append(fetchedReleases.Releases, release)
				fetchedReleases.LastRetrievedTime = time.Now().UTC()
			} else {
				allReleasesFetched = true
				break
			}
		}

		if res.NextPage == 0 {
			allReleasesFetched = true
		} else {
			listOptions.Page = res.NextPage
		}
	}

	return nil
}

func (r *GitHubReleasesMonitorReconciler) handleDeletion(ctx context.Context, githubReleases *githubv1.GitHubReleaseList, githubReleaseMonitor *githubv1.GitHubReleasesMonitor) error {
	log := log.FromContext(ctx)

	if controllerutil.ContainsFinalizer(githubReleaseMonitor, githubReleasesMonitorFinalizer) {
		log.Info("Deleting GithubRelease resources for GithubReleaseMonitor", "GithubReleaseMonitor", githubReleaseMonitor.Name)

		for _, githubRelease := range githubReleases.Items {
			log.Info("Deleting GithubRelease", "GithubRelease", githubRelease.Name)
			if err := r.Delete(ctx, &githubRelease); err != nil {
				log.Error(err, "unable to delete GithubRelease", "GithubRelease", githubRelease)
				return err
			}
		}

		controllerutil.RemoveFinalizer(githubReleaseMonitor, githubReleasesMonitorFinalizer)
		if err := r.Update(ctx, githubReleaseMonitor); err != nil {
			log.Error(err, "unable to update GithubReleaseMonitor")
			return err
		}
	}

	return nil
}

func (r *GitHubReleasesMonitorReconciler) buildGithubRelease(githubReleaseName string, release *github.RepositoryRelease, githubReleaseMonitor *githubv1.GitHubReleasesMonitor) (*githubv1.GitHubRelease, error) {

	assets := []*githubv1.GithubReleaseAsset{}
	for _, asset := range release.Assets {
		assets = append(assets, &githubv1.GithubReleaseAsset{
			ID:                 asset.ID,
			Name:               *asset.Name,
			BrowserDownloadURL: *asset.BrowserDownloadURL,
			URL:                *asset.URL,
			CreatedAt:          &metav1.Time{Time: asset.CreatedAt.Time},
			UpdatedAt:          &metav1.Time{Time: asset.UpdatedAt.Time},
		})
	}

	githubRelease := &githubv1.GitHubRelease{
		ObjectMeta: metav1.ObjectMeta{
			Labels:      make(map[string]string),
			Annotations: make(map[string]string),
			Name:        githubReleaseName,
			Namespace:   githubReleaseMonitor.Namespace,
		},
		Spec: githubv1.GitHubReleaseSpec{
			ID:          release.ID,
			Name:        *release.Name,
			TagName:     *release.TagName,
			URL:         *release.URL,
			Assets:      assets,
			JobTemplate: &githubReleaseMonitor.Spec.GitHubReleaseJobTemplateSpec,
		},
	}

	if err := ctrl.SetControllerReference(githubReleaseMonitor, githubRelease, r.Scheme); err != nil {
		return nil, err
	}

	return githubRelease, nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *GitHubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {

	if r.fetchedReleases == nil {
		r.fetchedReleases = &GitHubFetchedReleases{
			Releases: []*github.RepositoryRelease{},
		}
	}

	if err := mgr.GetFieldIndexer().IndexField(context.Background(), &githubv1.GitHubRelease{}, jobOwnerKey, func(rawObj client.Object) []string {
		gr := rawObj.(*githubv1.GitHubRelease)
		owner := metav1.GetControllerOf(gr)
		if owner == nil {
			return nil
		}
		if owner.APIVersion != apiGVStr || owner.Kind != "GitHubReleasesMonitor" {
			return nil
		}

		return []string{owner.Name}
	}); err != nil {
		return err
	}

	return ctrl.NewControllerManagedBy(mgr).
		For(&githubv1.GitHubReleasesMonitor{}).
		Owns(&githubv1.GitHubRelease{}).
		Complete(r)
}
